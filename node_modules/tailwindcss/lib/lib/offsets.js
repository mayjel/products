// @ts-check
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "Offsets", {
    enumerable: true,
    get: function() {
        return Offsets;
    }
});
const _bigSign = /*#__PURE__*/ _interop_require_default(require("../util/bigSign"));
const _remapbitfield = require("./remap-bitfield.js");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
class Offsets {
    constructor(){
        /**
     * Offsets for the next rule in a given layer
     *
     * @type {Record<Layer, bigint>}
     */ this.offsets = {
            defaults: 0n,
            base: 0n,
            components: 0n,
            utilities: 0n,
            variants: 0n,
            user: 0n
        };
        /**
     * Positions for a given layer
     *
     * @type {Record<Layer, bigint>}
     */ this.layerPositions = {
            defaults: 0n,
            base: 1n,
            components: 2n,
            utilities: 3n,
            // There isn't technically a "user" layer, but we need to give it a position
            // Because it's used for ordering user-css from @apply
            user: 4n,
            variants: 5n
        };
        /**
     * The total number of functions currently registered across all variants (including arbitrary variants)
     *
     * @type {bigint}
     */ this.reservedVariantBits = 0n;
        /**
     * Positions for a given variant
     *
     * @type {Map<string, bigint>}
     */ this.variantOffsets = new Map();
    }
    /**
   * @param {Layer} layer
   * @returns {RuleOffset}
   */ create(layer) {
        return {
            layer,
            parentLayer: layer,
            arbitrary: 0n,
            variants: 0n,
            parallelIndex: 0n,
            index: this.offsets[layer]++,
            propertyOffset: 0n,
            property: "",
            options: []
        };
    }
    /**
   * @param {string} name
   * @returns {RuleOffset}
   */ arbitraryProperty(name) {
        return {
            ...this.create("utilities"),
            arbitrary: 1n,
            property: name
        };
    }
    /**
   * Get the offset for a variant
   *
   * @param {string} variant
   * @param {number} index
   * @returns {RuleOffset}
   */ forVariant(variant, index = 0) {
        let offset = this.variantOffsets.get(variant);
        if (offset === undefined) {
            throw new Error(`Cannot find offset for unknown variant ${variant}`);
        }
        return {
            ...this.create("variants"),
            variants: offset << BigInt(index)
        };
    }
    /**
   * @param {RuleOffset} rule
   * @param {RuleOffset} variant
   * @param {VariantOption} options
   * @returns {RuleOffset}
   */ applyVariantOffset(rule, variant, options) {
        options.variant = variant.variants;
        return {
            ...rule,
            layer: "variants",
            parentLayer: rule.layer === "variants" ? rule.parentLayer : rule.layer,
            variants: rule.variants | variant.variants,
            options: options.sort ? [].concat(options, rule.options) : rule.options,
            // TODO: Technically this is wrong. We should be handling parallel index on a per variant basis.
            // We'll take the max of all the parallel indexes for now.
            // @ts-ignore
            parallelIndex: max([
                rule.parallelIndex,
                variant.parallelIndex
            ])
        };
    }
    /**
   * @param {RuleOffset} offset
   * @param {number} parallelIndex
   * @returns {RuleOffset}
   */ applyParallelOffset(offset, parallelIndex) {
        return {
            ...offset,
            parallelIndex: BigInt(parallelIndex)
        };
    }
    /**
   * Each variant gets 1 bit per function / rule registered.
   * This is because multiple variants can be applied to a single rule and we need to know which ones are present and which ones are not.
   * Additionally, every unique group of variants is grouped together in the stylesheet.
   *
   * This grouping is order-independent. For instance, we do not differentiate between `hover:focus` and `focus:hover`.
   *
   * @param {string[]} variants
   * @param {(name: string) => number} getLength
   */ recordVariants(variants, getLength) {
        for (let variant of variants){
            this.recordVariant(variant, getLength(variant));
        }
    }
    /**
   * The same as `recordVariants` but for a single arbitrary variant at runtime.
   * @param {string} variant
   * @param {number} fnCount
   *
   * @returns {RuleOffset} The highest offset for this variant
   */ recordVariant(variant, fnCount = 1) {
        this.variantOffsets.set(variant, 1n << this.reservedVariantBits);
        // Ensure space is reserved for each "function" in the parallel variant
        // by offsetting the next variant by the number of parallel variants
        // in the one we just added.
        // Single functions that return parallel variants are NOT handled separately here
        // They're offset by 1 (or the number of functions) as usual
        // And each rule returned is tracked separately since the functions are evaluated lazily.
        // @see `RuleOffset.parallelIndex`
        this.reservedVariantBits += BigInt(fnCount);
        return {
            ...this.create("variants"),
            variants: this.variantOffsets.get(variant)
        };
    }
    /**
   * @param {RuleOffset} a
   * @param {RuleOffset} b
   * @returns {bigint}
   */ compare(a, b) {
        // Sort layers together
        if (a.layer !== b.layer) {
            return this.layerPositions[a.layer] - this.layerPositions[b.layer];
        }
        // When sorting the `variants` layer, we need to sort based on the parent layer as well within
        // this variants layer.
        if (a.parentLayer !== b.parentLayer) {
            return this.layerPositions[a.parentLayer] - this.layerPositions[b.parentLayer];
        }
        // Sort based on the sorting function
        for (let aOptions of a.options){
            for (let bOptions of b.options){
                if (aOptions.id !== bOptions.id) continue;
                if (!aOptions.sort || !bOptions.sort) continue;
                var _max;
                let maxFnVariant = (_max = max([
                    aOptions.variant,
                    bOptions.variant
                ])) !== null && _max !== void 0 ? _max : 0n;
                // Create a mask of 0s from bits 1..N where N represents the mask of the Nth bit
                let mask = ~(maxFnVariant | maxFnVariant - 1n);
                let aVariantsAfterFn = a.variants & mask;
                let bVariantsAfterFn = b.variants & mask;
                // If the variants the same, we _can_ sort them
                if (aVariantsAfterFn !== bVariantsAfterFn) {
                    continue;
                }
                let result = aOptions.sort({
                    value: aOptions.value,
                    modifier: aOptions.modifier
                }, {
                    value: bOptions.value,
                    modifier: bOptions.modifier
                });
                if (result !== 0) return result;
            }
        }
        // Sort variants in the order they were registered
        if (a.variants !== b.variants) {
            return a.variants - b.variants;
        }
        // Make sure each rule returned by a parallel variant is sorted in ascending order
        if (a.parallelIndex !== b.parallelIndex) {
            return a.parallelIndex - b.parallelIndex;
        }
        // Always sort arbitrary properties after other utilities
        if (a.arbitrary !== b.arbitrary) {
            return a.arbitrary - b.arbitrary;
        }
        // Always sort arbitrary properties alphabetically
        if (a.propertyOffset !== b.propertyOffset) {
            return a.propertyOffset - b.propertyOffset;
        }
        // Sort utilities, components, etc‚Ä¶ in the order they were registered
        return a.index - b.index;
    }
    /**
   * Arbitrary variants are recorded in the order they're encountered.
   * This means that the order is not stable betu qw wy z{ {} Ö áÅ àÅ âÉ äÖ óá òâ ôã öã ç 	è 
ë ì ï ó #ô $õ *ù +ü 2° 3£ 7• 8ß @© A© B´ C´ D≠ E≠ FØ G± H≥ Iµ Jµ P∑ Uπ \ª cΩ iø n¡ s√ t≈ u« v… wÀ xÕ yœ z— {” ~’ ◊ ÄŸ Å€ Ü› áﬂ à· â„ äÂ ãÁ åÈ çÎ éÌ ìÔ îÒ ôÛ öı ù˜ û˘ ß˚ ®˝ ¨ˇ ≠ ≤ ≥ ∫ ª º	 Ω	 æ ø ƒ ≈ « Û Ù ı ˆ ˜   ! # % ' ) + %- &/ +1 ,3 /5 07 ë9 í9 `E  bG  rI , NM , PO 7 M 7 O 7 Q 7 S ? ®U ? ÆW ? ≤Y ? ∂[ ? ∫] ?  M ? ÃO l ^E m pI z ,	E { <	I É å	a á P
E à `
I ∞á£áΩá…á’á9 < œ ÷Ò%1Xeö«!3H 1wà?I©∞º->c{ãæ„˛V^{@Ô uÿ @˘ c @Bf @	æŒ @é¡ @“Œ @{q @)ít @3Àï @≠
c @Ø
æŒ f≈
∫æ F«
˝T f…
v
 FÀ
œ FÕ
ÌŒ Fœ
“Œ F—
‰ï F”

⁄ F’

⁄ F◊
Ñ FŸ
kK F€
∆“ F›
ö’ Fﬂ
j¡ F·
j¡ F„
|¡ fÂ
|¡ FÁ
û FÈ
û FÎ
¶é FÌ
`é FÔ
`é FÒ
∆b FÛ
v Fı
v F˜
W @˘
c @˚
´ÿ @˝
±´ &ˇ
a
 Fr F˚q F∆q F´q D	‚q Fåu Fßâ Fôï Fˆb fˆb DÔR D$S DÇ  DÇ D3K DPK ∞  ∞ @∞ H∞ P∞ Ä            î¢Ÿ             ã,T               ãNè               ãnà           ¥≤  ä  ã  å  ç  é  è  ê  ë  í  ì  î  ï  ñ  ó  ò  ô  ö  õ  ú  ù  û  ü  †  °  ¢  £  §  •  ¶  ß  ®  ©  ™  ´  ¨  ≠  Æ  Ø  ∞  ±  ≤  ≥  ¥  µ  ∂  ∑  ∏  π  ∫  ª  º  Ω  æ  ø  ¿  ¡  ¬  √  ƒ  ≈  ∆  «  »  …     À  Ã  Õ  Œ  œ  –  —  “  ”  ‘  ’  ÷  ◊  ÿ  Ÿ  ⁄  € R ‹ S › i ﬁ i ﬂ j ‡ j · Ñ ‚ â „ â ‰ â     q $I  q ∂§    s $I    u $I    $$I  $∂§    &$I    ∫$I    º$I   ã$I    $It ‚p Ër ‚t p r ä#
ä¡ä1äläµä8 ©+˘ ˘    ˝  ˘  ˘  
  ˝  ˘  ˘ 	 ˘  ˘      __StaticArrayInitTypeSize=10 CERT_QUERY_CONTENT_FLAG_PKCS10 CERT_QUERY_CONTENT_PKCS10 szOID_PKCS_10 __StaticArrayInitTypeSize=20 SystemFunction040 ALG_SID_RIPEMD160 CMSG_ENVELOPED_RECIPIENT_V0 <>c__DisplayClass30_0 <>c__DisplayClass31_0 <>c__DisplayClass32_0 <>c__DisplayClass33_0 <>9__25_0 <GetRSAPrivateKey>b__25_0 <>9__27_0 <GetDSAPrivateKey>b__27_0 <>c__DisplayClass28_0 <>c__DisplayClass29_0 <Pkcs1SignData>b__0 <Pkcs1VerifyData>b__0 <CreateLazyInvoker>b__0 <OaepSha1Decrypt>b__0 <Pkcs1Decrypt>b__0 <OaepSha1Encrypt>b__0 <Pkcs1Encrypt>b__0 <BindGetCapiPublicKey>b__0 <BindGetCapiPrivateKey>b__0 488FC8615F249EC7EA35CB695DAAF90CF852B211 SystemFunction041 ALG_SID_SHA1 CALG_SHA1 <>9__25_1 <GetRSAPrivateKey>b__25_1 <>9__9_1 <CreateLazyInvoker>b__9_1 szOID_PKCS_1 <>c__DisplayClass37_0`1 <>c__DisplayClass9_0`1 <>c__9`1 Func`1 Nullable`1 IEnumerable`1 Collection`1 IEnumerator`1 IList`1 Lazy`1 szOID_OIWSEC_sha1 value1 cbBuf1 pbBuf1 ALG_SID_3DES_112 CALG_3DES_112 szOID_OIWSEC_SHA512 szOID_PKCS_12 __StaticArrayInitTypeSize=32 ADVAPI32 KERNEL32 CRYPT32 Microsoft.Win32 UInt32 ReadInt32 WriteInt32 ToInt32 CAD8623838274740D6497489F547CE972C42A942 ALG_SID_AES_192 CALG_AES_192 ALG_SID_RC2 CALG_RC2 ALG_SID_MD2 CALG_MD2 CERT_PUBLIC_KEY_INFO2 CRYPT_ALGORITHM_IDENTIFIER2 X509_BASIC_CONSTRAINTS2 CMSG_ENVELOPED_RECIPIENT_V2 szOID_PKCS_2 <>c__DisplayClass36_0`2 Func`2 Dictionary`2 X509Certificate2 value2 cbBuf2 pbBuf2 collection2 DSS_PUB_MAGIC_VER3 DSS_PRIV_MAGIC_VER3 CMSG_ENVELOPED_RECIPIENT_V3 szOID_PKCS_3 Func`3 ALG_SID_SAFERSK64 UInt64 ReadInt64 WriteInt64 ToInt64 szOID_OIWSEC_SHA384 59F5BD34B6C013DEACC784F69C67E95150033A84 szOID_RSA_RC4 ALG_SID_RC4 CALG_RC4 ALG_SID_MD4 CALG_MD4 CMSG_ENVELOPED_RECIPIENT_V4 szOID_PKCS_4 Func`4 ALG_SID_RC5 CALG_RC5 ALG_SID_SSL3SHAMD5 CALG_SSL3_SHAMD5 szOID_RSA_MD5 ALG_SID_MD5 CALG_MD5 CALG_HUGHES_MD5 szOID_PKCS_5 Func`5 szOID_OIWSEC_SHA256 ALG_SID_AES_256 CALG_AES_256 szOID_PKCS_6 Func`6 CERT_STORE_SAVE_AS_PKCS7 CERT_STORE_PROV_PKCS7 szOID_PKCS_7 ALG_SID_SAFERSK128 ALG_SID_AES_128 CALG_AES_128 get_UTF8 szOID_PKCS_8 x509 <>9 szOID_PKCS_9 <Module> <PrivateImplementationDetails> fCA ALG_SID_IDEA ALG_SID_KEA ALG_SID_SHA CALG_SHA CERT_CHAIN_PARA CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA CMSG_CTRL_KEY_AGREE_DECRYPT_PARA CMSG_CTRL_DECRYPT_PARA CMSG_CTRL_KEY_TRANS_DECRYPT_PARA CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA CERT_CHAIN_POLICY_PARA szOID_X957_sha1DSA szOID_X957_DSA ALG_TYPE_RS